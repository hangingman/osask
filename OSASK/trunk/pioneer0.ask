// "pioneer0":ぐいぐいの標準ライブラリ ver.0.8
//  copyright(C) 2000 H.Kawai (川合秀実)

// これは、アプリケーションを書きやすくするための各種サービスを提供するプログラム。
// 結局のところ、処理をshellcallに取り次いでいるだけ。
// shellcallの仕様は流動的なので、このライブラリがその変化を吸収しているともいえる。

// スタックは1KBくらいあれば問題は無いだろう。

segment PioneerMdl(USE32, PARA);
default(code == PioneerMdl);

struct WORK { // 256bytes
	char signature[8]; int children_back, children_next;
	int softint_EIP, softint_CS, nest /* user用 */, read_ptr /* system用 */;
	int softint_ret_buf[16], softint_mask_buf[16]; // system用
	int signalbox_read_free, signalbox_eos, signalbox_rewind, signaldw /* user用 */;
	int signalbox_write_free, signalbox_write_ptr,
		signalbox_write_ptr0, signalbox_write_ptr1; // user用
	// 空きは160バイト
};

struct WINDOW {	// 128bytes
	char signature[8];
	int chain_back, chain_next;
	int children_back, children_next;
	int x_size, y_size;
	int slot;
	unsigned char mode0, draw_enable, [2];
	// 空きは88バイト
};

struct TEXTBOX { // 64bytes
	char signature[8];
	int chain_back, chain_next;
	int x_size, y_size, x0, y0;
	int option, backcolor, charset, window;
	void [16]; // 空きは16バイト
	int buffer[0];
};

void near textbox_drawback(); // テキストボックスの背景描画ルーチン

/*
	スロットの使用状況
		0x0000〜0x0170 : shell-call側でリザーブ
		0x01c0〜0x01e0 : システムタイマー
		0x01f0         : pioneerのワークエリア位置などを保存
		0x0200〜0x03f0 : ユーザーに解放
*/

void far pioneer0()
// Lv3のライブラリー
// セグメントは、DS == FS == SSである事を仮定している。
// コマンドはDS:EBX以降に格納されている。
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	segment PioneerMdl == CS;

	PUSHAD();
	(offset) cmd = EBX;
	if ((unsigned) cmd[0] != 0x0004) {
		// 最初のコマンドが初期化コマンドではない。

		EBX = 0xffffffff;
		EAX = 0x0004; // read user-slot command
		ECX = 0x01f0; // スロット番号(pioneerワークスロット)
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		(offset) work = EDX;

		// softint禁止
		LEA(EBX, work->softint_mask_buf[0]); // add_nest
	//	work->softint_mask_buf[ 8] = 0xff80; // (Llv変更しない)
		(int) [DS:EBX + 8] = 0xff80;
		DB(0x9a); DD(0); DW(0x0017); // shell-call(softint抑制)
	}

asmout("nextcmd:");
	EAX = cmd[0];
	if ((unsigned) EAX < 0x0090) {
		TEST(EAX, 0x03);
		if (== 0)
			asmout("JMP DWORD PTR CS:[EAX+#cmd_jumptable]");
	}

	// コマンド番号エラー
	// EAX    受理されなかったコマンド番号
	// DS:ESI そのコマンドへのポインタ

cmderr:
	LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更しない)
	DB(0x9a); DD(0); DW(0x0017); // shell-call(softint許可)
	(int) [SS:ESP + 16 /* EBX */] = (offset) cmd;
	TEST(ESP, ESP); // ZF = 0
	POPAD();
	return;

	ALIGN(4);
cmd_jumptable:
	asmout("DD OFFSET cmd000,  OFFSET cmd004,  OFFSET cmd008,  OFFSET #cmderr");
	asmout("DD OFFSET cmd010,  OFFSET #cmderr, OFFSET cmd018,  OFFSET #cmderr");
	asmout("DD OFFSET cmd020,  OFFSET cmd024,  OFFSET cmd028,  OFFSET cmd02c ");
	asmout("DD OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr");
	asmout("DD OFFSET cmd040,  OFFSET cmd044,  OFFSET #cmderr, OFFSET #cmderr");
	asmout("DD OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr");
	asmout("DD OFFSET cmd060,  OFFSET #cmderr, OFFSET cmd068,  OFFSET #cmderr");
	asmout("DD OFFSET cmd070,  OFFSET cmd074,  OFFSET cmd078,  OFFSET #cmderr");
	asmout("DD OFFSET cmd080,  OFFSET cmd084,  OFFSET #cmderr, OFFSET cmd08c ");
}

void far cmd000()
// 終了コマンド
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	// 待機中の割り込みを検査
	if (work->nest == 0) { // 割り込みはマスクされていない
		if (work->signalbox_read_free != 0) { // バッファにシグナルがある
			PUSH(EAX); // ESP -= 4;の代わり
			if ((unsigned) (int) [SS:ESP + 16 /* ESP */] != 1) {
				// ハンドラからの帰還要求は出ていない

				// 新規割り込み
				// スタックの積み替え

				// <積み替え後のスタック構成>
				//   +0 〜  +31 : PUSHADイメージ
				//  +32 〜  +43 : EIP, CS, EFLAGS
				//  +44 〜  +59 : ES, DS, FS, GS
				//  +60 〜  +91 : PUSHADイメージ
				//  +92 〜 +103 : EIP, CS, EFLAGS

				//   +0 〜  +43は、shellcallルーチンのために用意する
				//			(読み込まれると取り去られる)
				//  +44 〜 +103は、ハンドラが参照するために用意される

				PUSH(GS);
				PUSH(FS);
				PUSH(DS);
				PUSH(ES);
				PUSHFD();
				ESP -= 40;
				EAX = (int) [SS:ESP +  64]; // EDI
				ECX = (int) [SS:ESP +  68]; // ESI
				EDX = (int) [SS:ESP +  72]; // EBP
				(int) [SS:ESP +  60] = EAX;
				(int) [SS:ESP +  64] = ECX;
				(int) [SS:ESP +  68] = EDX;
				EAX = (int) [SS:ESP +  80]; // EBX
				ECX = (int) [SS:ESP +  84]; // EDX
				EDX = (int) [SS:ESP +  88]; // ECX
				(int) [SS:ESP +  76] = EAX;
				(int) [SS:ESP +  80] = ECX;
				(int) [SS:ESP +  84] = EDX;
				EAX = (int) [SS:ESP +  92]; // EAX
				ECX = (int) [SS:ESP +  96]; // EIP
				EDX = (int) [SS:ESP + 100]; // CS
				(int) [SS:ESP +  88] = EAX;
				(int) [SS:ESP +  92] = ECX;
				(int) [SS:ESP +  96] = EDX;
				EAX = (int) [SS:ESP + 40]; // EFLAGS
				(int) [SS:ESP + 100] = EAX;
			} else {
				// ハンドラからの帰還要求が出ている

				// スタックの上位(+44 〜 +103)は完成している
				// 下位(+0 〜 +43)を作り直す
				EAX = (int) [SS:ESP + 100]; // EFLAGS
				(int) [SS:ESP + 40] = EAX;
			}
			EAX = work->softint_EIP; // ハンドラへのベクタ
			ECX = work->softint_CS;
			(int) [SS:ESP + 32] = EAX;
			(int) [SS:ESP + 36] = ECX;
			(int) [SS:ESP + 12] = 2; // リターン時のLlv
			work->nest--; // 割り込んだので、マスクカウントを減少
			PUSH(FS);
			LEA(EBX, work->softint_ret_buf[0]);
			work->softint_ret_buf[ 4] = 0;
			work->softint_ret_buf[ 8] = 0x0080; // 割り込み抑制解除
			DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
			INT(0x03); // エラーが無い限り、ここにはこない
		}
	}

	// ハンドラへの分岐はない
	if ((unsigned) (int) [SS:ESP + 12] == 1) {
		// 帰還
		ESP += 40; // いらない部分を捨てる(EDI〜EAX, CS:EIP)
		POP(ES);
		POP(DS);
		POP(EAX); // FS直接ロードせずに、EAXに入れておく
		POP(GS);
		(int) [SS:ESP + 12] = 2; // リターン時のLlv
		PUSH(EAX); // ここで復帰後のFSを積む
		LEA(EBX, work->softint_ret_buf[0]);
		work->softint_ret_buf[ 4] = 0;
		work->softint_ret_buf[ 8] = 0x0080; // 割り込み抑制解除
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		INT(0x03); // エラーが無い限り、ここにはこない
	}

	// 何もないので、普通の正常終了
	LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更しない)
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	(int) [SS:ESP + 16 /* EBX */] = (offset) cmd;
	CMP(EAX, EAX); // ZF = 1, CF = 0
	POPAD();
	return;
}

void near cmd004()
// pioneer0ライブラリ初期化コマンド
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	// work初期化(256bytes)
	// optionフィールドをもつ(malloc領域などのため)
	// malloc領域などの設定は、別のコマンドであとからやる。
	(offset) work = cmd[4] /* opt */;
	(offset) cmd += 8;
	(int) work->signature[0] = 0x6e6f6970 ; /* pion */
	(int) work->signature[4] = 0x30726565 ; /* eer0 */
	LEA(EAX, work->children_back); 
	work->children_back = EAX;
	work->children_next = EAX;
	work->nest = 0xffffffff;
	work->read_ptr = 0;
	work->softint_ret_buf[ 0] = 0x0208;
	work->softint_ret_buf[12] = 0;
	work->signalbox_read_free = 0;
	work->softint_mask_buf[ 0] = 0x0204;
	work->softint_mask_buf[ 4] = 0;
	work->softint_mask_buf[ 8] = 0xff80;
	work->softint_mask_buf[12] = 0x0000;
	work->signaldw = 0;
	work->signalbox_write_ptr = 0xffffffff;
	// ベクタ初期化
	AX = CS;
	PUSH(FS);
	FS = AX;
	asmout("MOV EBX,OFFSET #cmd0004_cmd");
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	POP(FS);
	// slot 0x01f0に(offset) workを書き込み
	PUSH((int) 0);
	PUSH((offset) work);
	ESP -= 8;
	PUSH((int) 0x01f0); // slot-no.
	PUSH((int) 0x0080); // write user-slot
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 24;
//	// ユーザー割り込み抑制
	asmout("JMP nextcmd");
	ALIGN(4);
cmd0004_cmd:
	asmout("DD 0200H, OFFSET pioneer_softint, 010000C7H, 0201H"); // softint_vector
	asmout("DD 0204H, 0, 0281H"); // to Llv2(nestを80に)
	asmout("DD 0300H, 01C0H"); // 獲得(この時、インターバルモードが解除される)
asmout("cmd004_cmd2:");
	asmout("DD 0310H, 01C0H"); // 現在時刻設定
	asmout("DD 0318H, 01C0H, 0140H, 1, 0080H"); // メッセージ設定
	DD(0x0000);
}

void near cmd008()
// pioneer0ライブラリの終了
// オプションで、アプリ自体も終了するか、それともアプリは終了しないかを選べる
{
	// 全く未完成
	INT(0x03);
}

void near cmd010()
// softintベクタ設定
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[4] /* EIP */;
	ECX = cmd[8] /* CS */;
	(offset) cmd += 12;
	work->softint_EIP = EAX;
	work->softint_CS = ECX;
	asmout("JMP nextcmd");
}

void near cmd018()
// wait signal
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[8]; // signaldw
	EDI = cmd[4]; // opt
	work->signalbox_write_free += EAX;
	work->signalbox_read_free -= EAX;
	if ((unsigned) < 0) {
		// 書き込んだ以上に、読み込んだと報告された。
		// これは許しがたいエラーである。

		INT(0x03); // エラー処理未完成
	}
	if (EDI == 0x0080) {
		// 帰還要求を表すために、スタック内のESP値を1にする。
		(int) [SS:ESP + 12 /* ESP */] = 1;
	}
	EAX = cmd[12]; // nest
	work->nest += EAX;

	(offset) cmd += 16;
	TEST(EDI, 0xffffff70);
	if (!= 0) {
		// 無効オプション指定
		INT(0x03); // エラー処理未完成
	}

	int slot == EAX;
	slot = 0x01c0;

	TEST(EDI, 0x08);
	if (!= 0) {
		// set now time
		PUSH((int) 0x0000);
		PUSH((int) /* 0x01c0 */ slot);
		PUSH((int) 0x0310); // 現在時刻設定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 12;
	}

	TEST(EDI, 0x04);
	if (!= 0) {
		// add time
		// 本来なら最低加算時間のチェックがある
		PUSH((int) 0x0000);
		PUSH(cmd[8]);
		PUSH(cmd[4]);
		PUSH(cmd[0]);
		(offset) cmd += 12;
		PUSH((int) /* 0x01c0 */ slot);
		PUSH((int) 0x0314); // 時刻加算
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}

	// 以下はシグナルが溜まっていないときだけ有効
	if (work->signalbox_read_free == 0) {
		TEST(EDI, 0x02);
		if (!= 0) {
			// regist timer
			PUSH((int) 0x0000);
			PUSH((int) /* 0x01c0 */ slot);
			PUSH((int) 0x0308); // タイマー登録
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 12;
		}
		TEST(EDI, 0x01);
		if (!= 0) {
			// sleep
			LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更する)
			work->softint_mask_buf[ 8] = 0x0080;
			DB(0x9a); DD(0); DW(0x0017); // shell-call

			LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更しない)
			work->softint_mask_buf[ 8] = 0xff80;
				// ライブラリルーチン内に再入したので、割り込みマスク
			DB(0x9a); DD(0); DW(0x0017); // shell-call
		}
		TEST(EDI, 0x02);
		if (!= 0) {
			// cancel timer
			PUSH((int) 0x0000);
			PUSH((int) /* 0x01c0 */ slot);
			PUSH((int) 0x030c); // タイマー解約
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 12;
		}
	}
	asmout("JMP nextcmd");
}

void near cmd020()
// create new window.
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	// WINDOW構造体の初期化など
	WINDOW *cmd0020_win == DS:EDI;
	(offset) cmd0020_win = cmd[ 4]; // work_ptr
	LEA(EAX, cmd0020_win->children_back); 
	cmd0020_win->children_back = EAX;
	cmd0020_win->children_next = EAX;
	LEA(EAX, cmd0020_win->chain_back);
	ECX = work->children_back;
	work->children_back = EAX;
	(int) [DS:ECX + 4] /* back->next */ = EAX;
	LEA(EAX, work->children_back);
	cmd0020_win->chain_back = ECX;
	cmd0020_win->chain_next = EAX;
	// signatureも初期化しなければいけない

	EAX = cmd[ 8]; // slot-no
	ECX = cmd[12]; // x-size
	EDX = cmd[16]; // y-size
	(offset) cmd += 20;
	ECX += 8 + 8; // 左右に8dotずつ確保
	EDX += 29 + 8; // 上に29dot、下に8dot確保
	cmd0020_win->x_size = ECX;
	cmd0020_win->y_size = EDX;
	cmd0020_win->slot = EAX;
	PUSH((int) 0 /* EOC */);
	(int) cmd0020_win->mode0 = 0;
	PUSH((int) 0x0040 /* signal-base */);
	PUSH((int) 0x0140 /* signalbox(slot番号で指定) */);
	PUSH(EDX /* y-size */);
	PUSH(ECX /* x-size */);
	PUSH((offset) cmd0020_win /* user-no */);
	PUSH(EAX /* slot-no */);
	PUSH((int) 0x0100 /* cmd-no */);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 32;
	asmout("JMP nextcmd");
}

void near cmd024()
// windowクローズ
{
	// 全く未完成
	INT(0x03);
}

void near cmd028()
// open text box
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	WINDOW *cmd0028_win == DS:EDI;
	TEXTBOX *cmd0028_textbox == DS:EBX;
	(offset) cmd0028_textbox = cmd[ 8]; // work_ptr
	(offset) cmd0028_win = cmd[32]; // window
	(int) cmd0028_textbox->signature[0] = 0x54584554; // 'TEXT'
	LEA(EAX, cmd0028_textbox->chain_back);
	ECX = cmd0028_win->children_back;
	cmd0028_win->children_back = EAX;
	(int) [DS:ECX + 4] /* back->next */ = EAX;
	LEA(EAX, cmd0028_win->children_back);
	cmd0028_textbox->chain_back = ECX;
	cmd0028_textbox->chain_next = EAX;
	EAX = cmd[ 4]; // opt
	ECX = cmd[12]; // 
	TEST(EAX, 0x0001);
	if (== 0) {
		ECX = 0x0008;
		// titleの時は、アクティブかどうかによって色が変わるので、初期値を設定しない
	}
	cmd0028_textbox->option = EAX;
	cmd0028_textbox->backcolor = ECX;
	cmd0028_textbox->window = (offset) cmd0028_win;
	EAX = cmd[16]; // x_size(キャラクター数)
	ECX = cmd[20]; // y_size(キャラクター数)
	cmd0028_textbox->x_size = EAX;
	cmd0028_textbox->y_size = ECX;
	EAX = cmd[24]; // x0
	ECX = cmd[28]; // y0
	EAX += 8;
	ECX += 29;
	cmd0028_textbox->x0 = EAX;
	cmd0028_textbox->y0 = ECX;
	EDX = cmd[36]; // キャラクターセット(slot-no)
	ECX = cmd[40]; // space code.
	(offset) cmd += 44;

	// バッファの初期化
	cmd0028_textbox->charset = EDX;
	EAX = cmd0028_textbox->x_size;
	PUSH((offset) cmd0028_textbox);
	MUL(cmd0028_textbox->y_size);
	EDX = cmd0028_textbox->backcolor;
	EDX <<= 16;
	(offset) cmd0028_textbox += 64;
	do {
		(int) [cmd0028_textbox    ] = ECX;
		(int) [cmd0028_textbox + 4] = EDX;
		(offset) cmd0028_textbox += 8;
		EAX--;
	} while (!= 0);
	POP((offset) cmd0028_textbox);

	if (AL != cmd0028_win->draw_enable) { // AL == 0
		// もし、描画フラグが1なら、更新する(フレームを描くとか、背景色をセットするとか)。
		EAX = cmd0028_textbox->option;
		TEST(EAX, 0xf000);
		if (== 0) {
			TEST(AL, 0x01);
			if (!= 0) {
				EDX = cmd0028_win->slot;
				PUSH(ESI);
				ESI = (offset) cmd0028_textbox;
				// EDX:win_slot, ESI:textbox
				EAX = 0x0020;
				textbox_drawback();
				POP(ESI);
			}
		}
	}
	asmout("JMP nextcmd");
}

void near cmd02c()
// close text box
{
	// 全く未完成
	INT(0x03);
}

void near cmd040()
// put string
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	WINDOW *cmd0040_win == DS:EDI;
	TEXTBOX *cmd0040_textbox == DS:EBX;
	(offset) cmd0040_textbox = cmd[16];
	EAX = cmd[12]; // y_pos
	MUL(cmd0040_textbox->x_size);
	EAX += cmd[ 8]; // x_pos
	EDX = cmd0040_textbox->backcolor;
	CL = (char) cmd[4]; TEST(CL, 0x01); // option
	if (!= 0) {
		EDX = cmd[24]; // back_color
	}
	EDX <<= 16;
	EDX |= cmd[20]; // color
	(offset) cmd0040_win = cmd0040_textbox->window;
	ECX = cmd[28]; // length
	if (cmd0040_win->draw_enable != 0) {
		PUSHAD();
		ESP -= 512;
		EAX = cmd0040_win->slot;
		(int) [SS:ESP     ] = 0x0404; /* put text */
		(int) [SS:ESP +  4] = 0x0000; /* option */
		(int) [SS:ESP +  8] = EAX;
		(int) [SS:ESP + 32] = ECX; // length
		ECX = cmd0040_textbox->charset;
		EAX = cmd0040_textbox->option; TEST(EAX, 0xf000); // option
		(int) [SS:ESP + 28] = ECX; // charset
		if (== 0) {
			// normal
			EDX >>= 16;
			(int) [SS:ESP + 24] = EDX; // back_color
			ECX = cmd[12]; // y_pos
			EAX = cmd[ 8]; // x_pos
			ECX *= 8;
			EAX *= 8;
			DL = (char) cmd0040_textbox->option; TEST(DL, 0x10); // option
			if (== 0)
				ECX *= 2;
			EAX += cmd0040_textbox->x0;
			ECX += cmd0040_textbox->y0;
			EDX = cmd[20]; // color
			(int) [SS:ESP + 12] = EAX; /* x0 */
			(int) [SS:ESP + 16] = ECX; /* y0 */
			(int) [SS:ESP + 20] = EDX; // color
		} else {
			// title
			EAX = cmd0040_win->mode0;
			(int) [SS:ESP + 12] = 24; /* x0 */
			asmout("MOV EAX,CS:[EAX*4+wintitle_colortable]");
			(int) [SS:ESP + 16] =  5; /* y0 */
			ECX = EAX;
			EAX &= 0xff;
			ECX /= 256;
			(int) [SS:ESP + 20] = EAX; /* color */
			(int) [SS:ESP + 24] = ECX; /* backcolor */
		}
		(offset) cmd += 32;
		LEA(EBX, [SS:ESP + 36]);
		ECX = (int) [SS:ESP + 32]; // length
		do {
			EAX = *cmd;
			(offset) cmd += 4;
			(int) [DS:EBX] = EAX;
			EBX += 4;
			ECX--;
		} while (!= 0);
		(int) [DS:EBX] = /* 0 */ ECX;
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 512;
		POPAD();
	}
	(offset) cmd += 32;
	if (ECX != 0) {
		LEA(EBX, [(offset) cmd0040_textbox + EAX * 8 + 64]);
		do {
			EAX = *cmd;
			(offset) cmd += 4;
			(int) [DS:EBX    ] = EAX;
			(int) [DS:EBX + 4] = EDX;
			EBX += 8;
			ECX--;
		} while (!= 0);
	}
	asmout("JMP nextcmd");
	ALIGN(4);
	asmout("wintitle_colortable DD 0008H, 0708H, 0, 040FH");
}

void near cmd044()
// line & box
//  +00 : cmd
//  +04 : opt
//  +08 : 0(window/graphicbox)
//  +0c : color
//  +10 : x0
//  +14 : y0
//  +18 : x1
//  +1c : y1
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	ESP -= 36;
	EAX = cmd[ 4]; // opt
	ECX = cmd[12]; // color
	(int) [SS:ESP +  0] = 0x0400; // cmd
	(int) [SS:ESP +  4] = EAX; // opt
	(int) [SS:ESP +  8] = 0; // slot
	(int) [SS:ESP + 28] = ECX; // color
	EAX = cmd[16]; // x0
	ECX = cmd[20]; // y0
	(int) [SS:ESP + 12] = EAX; // x0
	(int) [SS:ESP + 16] = ECX; // y0
	EAX = cmd[24]; // x1
	ECX = cmd[28]; // y1
	(offset) cmd += 32;
	(int) [SS:ESP + 20] = EAX; // x1
	(int) [SS:ESP + 24] = ECX; // y1
	(int) [SS:ESP + 32] = 0; // eoc
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 36;
	asmout("JMP nextcmd");
}

void near cmd060()
// define signalbox
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	if (work->signalbox_write_ptr == 0xfffffffe) {
		// ユーザーシグナル待ち
		PUSH((int) 0x0000); // eoc
		PUSH((int) 0xff02); // nest
		PUSH((int) 0); // signals
		PUSH((int) 0x0204); // add nest
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 16;
	}

	ECX = cmd[4]; // bytes /* bit0, 1はreserve */
	EAX = cmd[8]; // work_ptr
	ECX -= 4;
	LEA(EDX, [EAX + ECX]);
	ECX /= 4;
	work->signalbox_write_ptr = EAX;
	work->signalbox_write_ptr0 = EAX;
	work->signalbox_write_ptr1 = EDX;
	work->signalbox_write_free = ECX;
	work->signalbox_read_free = 0;
	ECX = cmd[12]; // eos
	EDX = cmd[16]; // rewind
	work->signalbox_eos = ECX;
	work->signalbox_rewind = EDX;
	(offset) cmd += 20;
	(int) [DS:EAX] = ECX; // eos
	asmout("JMP nextcmd");
}

void near cmd068()
// define signal
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[4]; // opt
	TEST(AH, 0x30);
	if (!= 0) {
		// リザーブビット
		INT(0x03);
	}
	ECX = cmd[20]; // signal_length
	if ((unsigned) ECX >= 2) {
		// 1dwより長いシグナルには未対応
		INT(0x03);
	}
	if (ECX != 0) {
		// シェルに設定を送信：0x7f000001 signal
		EAX = cmd[8]; // device
		if (EAX == 0x0010 /* timer */) {
			PUSH((int) 0x0000);
			PUSH(cmd[24]); // signal
			PUSH((int) 0x7f000001);
			PUSH((int) 2 /* length */);
			PUSH((int) 0x0140);
			PUSH(cmd[12]); // timer slot-no
			PUSH((int) 0x0318);
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 28;
		} else if (EAX == 0x0100) {
			WINDOW *cmd0068_win == DS:EDX;
			(offset) cmd0068_win = cmd[16]; // window
			if (EAX != 0x0100 /* decoded keycode */) {
				INT(0x03);
			}
			PUSH((int) 0);
			PUSH((int) 0);
			PUSH((int) 0); // for purpose
			PUSH(cmd[24]); // signal
			PUSH((int) 0x7f000001);
			PUSH((int) 2);
			PUSH((int) 0x0140 /* system signalbox(slot番号で指定) */);
			// ここにウィンドウ番号を入れた方がいいのでは？
			// もちろん、これもデフォルトの要請であって、受理されるとは限らない。
			PUSH(cmd0068_win->slot);
			PUSH(cmd[12]); // keycode
			PUSH(cmd[ 8]); // device
			PUSH(cmd[ 4]); // opt
			PUSH((int) 0x0510); // signal設定
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 48;
		}
		(offset) cmd += 28;
		EAX = cmd[0];
		LEA((offset) cmd, [cmd + EAX * 4 + 4]);
		asmout("JMP nextcmd");
	} else {
		(offset) cmd += 24;
		EAX = cmd[0];
		LEA((offset) cmd, [cmd + EAX * 4 + 4]);
		asmout("JMP nextcmd");
	}
}

void near cmd070()
// タイマーノードオープン
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EDX = cmd[4];
	(offset) cmd += 8;
	if (EDX == 0x01c0) {
		// ユーザーモードに変更
		// 初期化する
cmd074_intervaloff:
		EAX = 0;
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EDX);
		PUSH((int) 0x031c); // インターバル指定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
		asmout("JMP nextcmd");
	}
	PUSH((int) 0x0000);
	PUSH(EDX);
	PUSH((int) 0x0300); // タイマーノード取得
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 12;
	asmout("JMP nextcmd");
asmout("cmd074_intervaloff EQU #cmd074_intervaloff");
}

void near cmd074()
// タイマーノードクローズ
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EDX = cmd[4];
	(offset) cmd += 8;
	if (EDX == 0x01c0) {
		// システムモードに変更
		// 初期化する

		AX = CS;
		PUSH(FS);
		FS = AX;
		asmout("MOV EBX,OFFSET cmd004_cmd2");
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		POP(FS);
		asmout("JMP cmd074_intervaloff");
	}
	PUSH((int) 0x0000);
	PUSH(EDX);
	PUSH((int) 0x0304); // タイマーノード返却
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 12;
	asmout("JMP nextcmd");
}

void near cmd078()
// タイマー設定
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	// signalはここで設定しない
	// 時刻やインターバルを設定
	// シグナル定義時のdeviceは0x0010

	EDI = cmd[4]; // optionフィールド
	EDX = cmd[8]; // slot
	(offset) cmd += 12;

	TEST(EDI, 0x20); // bit5 : 現在時刻ロード
	if (!= 0) {
		PUSH((int) 0x0000);
		PUSH(EDX);
		PUSH((int) 0x0310); // 現在時刻設定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 12;
	}
	TEST(EDI, 0x10); // bit4 : 時刻加算(時刻フィールドを伴う)
	if (!= 0) {
		PUSH((int) 0);
		PUSH(cmd[8]);
		PUSH(cmd[4]);
		PUSH(cmd[0]);
		(offset) cmd += 12;
		PUSH(EDX);
		PUSH((int) 0x0314); // 時刻加算
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}
	TEST(EDI, 0x08); // bit3 : インターバル指定(インターバルフィールドを伴う)
	if (!= 0) {
		PUSH((int) 0);
		PUSH(cmd[8]);
		PUSH(cmd[4]);
		PUSH(cmd[0]);
		(offset) cmd += 12;
		PUSH(EDX);
		PUSH((int) 0x031c); // インターバル指定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}
	TEST(EDI, 0x04); // bit2 : インターバル解除(単発モード)
	if (!= 0) {
		EAX = 0;
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EDX);
		PUSH((int) 0x031c); // インターバル指定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}
	TEST(EDI, 0x02); // bit1 : タイマー始動
	if (!= 0) {
		PUSH((int) 0x0000);
		PUSH(EDX);
		PUSH((int) 0x0308); // タイマー登録
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 12;
	}
	TEST(EDI, 0x01); // bit0 : タイマー停止
	if (!= 0) {
		PUSH((int) 0x0000);
		PUSH(EDX);
		PUSH((int) 0x030c); // タイマー解除
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 12;
	}
	asmout("JMP nextcmd");
}

void near cmd080()
// サウンドトラックオープン
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[8] /* reserve */);
	PUSH(cmd[4] /* opt & slot */);
	PUSH((int) 0x0600);
	(offset) cmd += 12;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 16;

	// sleep
	LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更する)
	work->softint_mask_buf[ 8] = 0x0080;
	DB(0x9a); DD(0); DW(0x0017); // shell-call

	LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更しない)
	work->softint_mask_buf[ 8] = 0xff80;
		// ライブラリルーチン内に再入したので、割り込みマスク
	DB(0x9a); DD(0); DW(0x0017); // shell-call

	asmout("JMP nextcmd");
}

void near cmd084()
// サウンドトラッククローズ
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[4] /* opt & slot */);
	PUSH((int) 0x0604);
	(offset) cmd += 8;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 12;
	asmout("JMP nextcmd");
}

void near cmd08c()
// 周波数指定によるサウンドオン／オフ
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[8]);
	PUSH(cmd[4] /* opt & slot */);
	PUSH((int) 0x060c);
	(offset) cmd += 12;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 16;
	asmout("JMP nextcmd");
}

void far pioneer_softint()
{
	WORK *work == SS:EBP;
	int *signal == GS:ESI;

	PUSH(DS);
	PUSH(GS);
	AX = SS;
	ECX = 0x0027; // system signalbox selector
	DS = AX;
	FS = AX;
	GS = CX;

	EBX = 0xffffffff;
	EAX = 0x0004; // リードユーザースロットコマンド
	ECX = 0x01f0;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	(offset) work = EDX;

	(offset) signal = work->read_ptr;
	work->signaldw = 0;
	do {
		EAX = signal[0];
		if (EAX == 0) {
			// terminate
			break;
		}

		if ((signed) <)
			goto usersignal;
		if ((unsigned) EAX >  0x7f0000ff)
			goto undefined;
		if ((unsigned) EAX >= 0x7f000000)
			goto headercut;
		if (EAX == 0x0080)
			goto sig0080; // system-timer time out
		if (EAX == 1)
			goto sig0001; // rewind
		if (EAX == 0x40)
			goto sig0040; // set window position
		if (EAX == 0x41)
			goto sig0041; // window
		if (EAX == 0x42)
			goto sig0042; // window
		if (EAX == 0x43)
			goto sig0043; // window
		if (EAX == 0x44)
			goto sig0044; // window
		if (EAX == 0x48)
			goto sig0048; // window
		if (EAX == 0xc0)
			goto sig00c0; // open sound track
		if (EAX == 0xc8)
			goto sig00c8; // enable sound track
		INT(0x03);

usersignal:
	// ユーザーシグナル：未対応
	INT(0x03);

undefined:
	// 未定義のシグナル
	INT(0x03);

headercut:
	// ユーザーシグナル(ヘッダーカット)
	EDX = work->signalbox_write_ptr;
	EAX &= 0xff;
	if (EDX != 0xffffffff) {
		LEA(ECX, [EDX + EAX * 4]);
		if ((unsigned) ECX >= work->signalbox_write_ptr1 /* 書き込み上限アドレス */) {
			// 先頭に戻す
			// 捨てるdw数を計算
			ECX = work->signalbox_write_ptr1;
			ECX -= EDX;
			ECX /= 4; // ECX == 先頭に戻すことによって消費するサイズ(dw単位)
			work->signalbox_read_free += ECX;
			work->signalbox_write_free -= ECX;
			if ((unsigned) < 0) {
				INT(0x03);
			//	work->signalbox_read_free -= ECX;
			//	work->signalbox_write_free += ECX;
			//	work->signalbox_status |= 0x01 /* buffer overrun */;
			//	goto skip_signalwrite;
			} else {
				[DS:EDX + 4] = ECX;
				ECX = work->signalbox_rewind;
				[DS:EDX] = ECX;
				EDX = work->signalbox_write_ptr0;
			}
		}
		work->signalbox_read_free += EAX;
		work->signalbox_write_free -= EAX;
		if ((unsigned) < 0) {
			// ユーザー用のsignalboxがあふれた
			INT(0x03);
		//	work->signalbox_read_free -= EAX;
		//	work->signalbox_write_free += EAX;
		//	work->signalbox_status |= 0x01 /* buffer overrun */;
		//	goto skip_signalwrite;
		}
		work->signaldw++;
		(offset) signal += 4;
		work->signaldw += EAX;
		do {
			ECX = *signal;
			(offset) signal += 4;
			(int) [DS:EDX] = ECX;
			EDX += 4;
			EAX--;
		} while (!= 0);
		EAX = work->signalbox_eos;
		work->signalbox_write_ptr = EDX;
		(int) [DS:EDX] = EAX;
		// nestによらず、目を覚まさせる
		(char) [SS:ESP + 8 /* GS, DS */ + 16] = 0x02; // リターン時にLlv2へ。
	} else {
		// このシグナルは処理しないで、シグナル処理そのものを一時的に凍結。
		work->signalbox_write_ptr = 0xfffffffe;
		// nestを0x02だけ減らす。
		EAX = work->signaldw;
		POP(GS);
		POP(DS);
		LEA(EBX, work->softint_ret_buf[0]);
		work->softint_ret_buf[ 4] /* (int) [DS:EBX + 4] */ = EAX;
		work->softint_ret_buf[ 8] /* (int) [DS:EBX + 8] */ = 0x00ff; // さらに1引く
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		// 割り込みから復帰してしまう
	}
	goto nextsignal;

sig0080:
	// システムタイマータイムアウト
	(offset) signal += 4;
	work->signaldw++;
	(char) [SS:ESP + 8 + 16 /* ESP */] = 0x02; // リターン時にLlv2へ。
	goto nextsignal;

sig00c0:
	// open sound track
	EDX = signal[4]; // slot
	EAX = signal[8]; // system-id
	(offset) signal += 12;
	work->signaldw += 3;
	(char) [SS:ESP + 8 + 16 /* ESP */] = 0x02; // リターン時にLlv2へ。
	EDX |= 0x01; // system-id defined
	PUSH((int) 0);
	PUSH(EAX);
	PUSH(EDX);
	PUSH((int) 0x0600);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 16;
	goto nextsignal;

sig00c8:
	// enable sound track
	EDX = signal[4]; // slot
	(offset) signal += 8;
	work->signaldw += 2;
	EDX |= 0x01; // enable
	PUSH((int) 0);
	PUSH(EDX);
	PUSH((int) 0x0608);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 12;
	goto nextsignal;

sig0001:
	// rewind
	EAX = signal[4];
	(offset) signal = 0;
	work->signaldw += EAX;
	goto nextsignal;

sig0040:
	// window位置変更
	// 描画は全てwindow相対モードを使うので、このシグナルに応じる必要が無い
//	EAX = signal[ 8];
//	ECX = signal[12];
	(offset) signal += 16;
//	*win_x0 = EAX; // win_x0
//	*win_y0 = ECX; // win_y0
	work->signaldw += 4;
	goto nextsignal;

sig0041:
	// タイトルバーカラー変更
	// bit0 : 0 = 長期にわたり、自由表示disable, 1 = enable
	// bit1 : 0 = 入力アクティブではない, 1 = 入力アクティブ
	// ぐいぐいでは、10の組み合わせをしないことを保証している。重なっていると入力アクティブにならない。
	// 入力アクティブになると、カーソルを表示する。

	WINDOW *sig0041_win == DS:EBX;
	(offset) sig0041_win = signal[4];
	AL = (char) signal[8];
	sig0041_win->mode0 = AL;
	(offset) signal += 12;
	work->signaldw += 3;
	goto nextsignal;

sig0042:
	// VRAMアクセスの自由化
	WINDOW *sig0042_win == DS:EBX;
	(offset) sig0042_win = signal[4];
	(offset) signal += 8;
	work->signaldw += 2;
	sig0042_win->draw_enable = 1; // 自由表示enable（随時更新）
	goto nextsignal;

sig0043:
	// ウィンドウクローズ要求
//	WINDOW *sig0043_win == DS:EBX;
//	(offset) sig0043_win = signal[4];
//	(offset) signal += 8;
//	work->signaldw += 2;

	PUSH((int) 0);
	PUSH((int) 0); // reserve
	PUSH((int) 0x0040); // タスク終了
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall

sig0044:
	// VRAMアクセスの凍結
	WINDOW *sig0044_win == DS:EBX;
	(offset) sig0044_win = signal[4];
	(offset) signal += 8;
	work->signaldw += 2;
	sig0044_win->draw_enable = 0; // 自由表示disable（更新抑制）
	// 受理したことをシェルにシステムコールで伝える
	PUSH((int) 0);
	PUSH(sig0044_win->slot);
	PUSH((int) 0x0140);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 12;
	goto nextsignal;

sig0048:
	// 再描画(他のタスクによって、持ち場が荒らされた)
	WINDOW *sig0048_win == DS:EDI;
	(offset) sig0048_win = signal[4];
	(offset) signal += 8;
	work->signaldw += 2;
	// 枠を描く
	PUSH(ESI);
	EDX = sig0048_win->slot;
	ESP -= 512;
	EAX = sig0048_win->x_size;
	ECX = sig0048_win->y_size;
	EAX--;
	ECX--;
	(int) [SS:ESP + 508] = EBP; // EBP待避
	EBP = 0;
	ESI = 0x0400;
	EBX = 0x0020;
	(int) [SS:ESP      ] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP +   4] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP +   8] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  12] = /*  0 */ EBP /* x0 */;
	(int) [SS:ESP +  16] = /*  0 */ EBP /* y0 */;
	(int) [SS:ESP +  20] = EAX /* x1 */;
	(int) [SS:ESP +  24] = /*  0 */ EBP /* y1 */;
	(int) [SS:ESP +  28] =  8 /* color */;
	(int) [SS:ESP +  32] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP +  36] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = /*  0 */ EBP /* x0 */;
	(int) [SS:ESP +  48] = /*  0 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = /*  0 */ EBP /* x1 */;
	(int) [SS:ESP +  56] = ECX /* y1 */;
	(int) [SS:ESP +  60] =  8 /* color */;
	(int) [SS:ESP +  64] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP +  68] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP +  72] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  76] = /*  0 */ EBP /* x0 */;
	(int) [SS:ESP +  80] = ECX /* y0 */;
	(int) [SS:ESP +  84] = EAX /* x1 */;
	(int) [SS:ESP +  88] = ECX /* y1 */;
	(int) [SS:ESP +  92] = /* 0 */ EBP /* color */;
	(int) [SS:ESP +  96] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP + 100] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP + 104] = EDX /* window(slot-no) */;
	(int) [SS:ESP + 108] = EAX /* x0 */;
	(int) [SS:ESP + 112] = /*  0 */ EBP /* y0 */;
	(int) [SS:ESP + 116] = EAX /* x1 */;
	(int) [SS:ESP + 120] = ECX /* y1 */;
	(int) [SS:ESP + 124] = /* 0 */ EBP /* color */;
	(int) [SS:ESP + 128] = /* 0x0000 */ EBP /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EAX--;
	ECX--;
//	EBP++; // EBP = 1;
//	ESI = 15;
//	EBX = 7;
	LEA(ESI, [EBP /* 0 */ + 15]);
	LEA(EBX, [EBP /* 0 */ + 7]);
	EBP++;
//	(int) [SS:ESP      ] = 0x0400 /* line command */;
//	(int) [SS:ESP +   4] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +   8] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  12] = /*  1 */ EBP /* x0 */;
	(int) [SS:ESP +  16] = /*  1 */ EBP /* y0 */;
	(int) [SS:ESP +  20] = EAX /* x1 */;
	(int) [SS:ESP +  24] = /*  1 */ EBP /* y1 */;
	(int) [SS:ESP +  28] = 15 /* color */;
//	(int) [SS:ESP +  32] = 0x0400 /* line command */;
//	(int) [SS:ESP +  36] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = /*  1 */ EBP /* x0 */;
	(int) [SS:ESP +  48] = /*  1 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = /*  1 */ EBP /* x1 */;
	(int) [SS:ESP +  56] = ECX /* y1 */;
	(int) [SS:ESP +  60] = 15 /* color */;
//	(int) [SS:ESP +  64] = 0x0400 /* line command */;
//	(int) [SS:ESP +  68] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  72] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  76] = /*  1 */ EBP /* x0 */;
	(int) [SS:ESP +  80] = ECX /* y0 */;
	(int) [SS:ESP +  84] = EAX /* x1 */;
	(int) [SS:ESP +  88] = ECX /* y1 */;
	(int) [SS:ESP +  92] =  7 /* color */;
//	(int) [SS:ESP +  96] = 0x0400 /* line command */;
//	(int) [SS:ESP + 100] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP + 104] = EDX /* window(slot-no) */;
	(int) [SS:ESP + 108] = EAX /* x0 */;
	(int) [SS:ESP + 112] = /*  1 */ EBP /* y0 */;
	(int) [SS:ESP + 116] = EAX /* x1 */;
	(int) [SS:ESP + 120] = ECX /* y1 */;
	(int) [SS:ESP + 124] =  7 /* color */;
//	(int) [SS:ESP + 128] = 0x0000 /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EAX--;
	ECX--;
	EBP++; // EBP = 2;
	ESI = 0;
//	(int) [SS:ESP      ] = 0x0400 /* line command */;
//	(int) [SS:ESP +   4] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +   8] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  12] = /*  2 */ EBP /* x0 */;
	(int) [SS:ESP +  16] = /*  2 */ EBP /* y0 */;
	(int) [SS:ESP +  20] = EAX /* x1 */;
	(int) [SS:ESP +  24] = ECX /* y1 */;
	(int) [SS:ESP +  28] =  8 /* color */;
	ECX = sig0048_win->mode0;
	EAX -= 2;
	EBP += 2; // EBP = 4;
	asmout("MOV ECX,CS:[ECX*4+#wintitle_colortable]");
//	(int) [SS:ESP +  32] = 0x0400 /* line command */;
//	(int) [SS:ESP +  36] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = /*  4 */ EBP /* x0 */;
	(int) [SS:ESP +  48] = /*  4 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = EAX /* x1 */;
	(int) [SS:ESP +  56] =  21 /* y1 */;
	(char) [SS:ESP + 60] = CH /* color */;
	(int) [SS:ESP +  64] = /* 0x0000 */ ESI /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EBP = (int) [SS:ESP + 508]; // EBP復帰

	// このウィンドウについているコンポーネントをサーチして、全て描画する
	LEA(EAX, sig0048_win->children_back);
	ESI = sig0048_win->children_next;
	if (EAX != ESI) {
		do {
			ESI -= 8;
			EAX = (int) [DS:ESI    ];
			ECX = (int) [DS:ESI + 4];
			if (EAX == 0x54584554 /* TEXT */) {
				// textbox
				TEXTBOX *sig0048_textbox == DS:ESI;
				EAX = sig0048_textbox->option;
				TEST(EAX, 0xf000);
				if (== 0) {
					// 普通のテキストボックス
					int *sig0048_textbox_ycnt    == SS:ESP + 496;
					int *sig0048_textbox_saveEDX == SS:ESP + 500; // win_slot(xdot)
					int *sig0048_textbox_saveEBP == SS:ESP + 504; // work(xcnt)
					int *sig0048_textbox_saveEDI == SS:ESP + 508; // win(buffer)
					TEST(EAX, 0x01);
					*sig0048_textbox_saveEDX = EDX;
					*sig0048_textbox_saveEBP = EBP;
					*sig0048_textbox_saveEDI = EDI;
					if (!= 0) {
						ESP += 512 - 12;
						// EDX:win_slot, ESI:textbox
						EAX = 0x0010;
						textbox_drawback();
						ESP -= 512 - 12;
					}
					// バッファを参照して書き込む
					(int) [SS:ESP     ] = 0x0404; /* put text */
					(int) [SS:ESP +  4] = 0x0000; /* option */
					(int) [SS:ESP +  8] = EDX;
					EAX = sig0048_textbox->charset;
					(int) [SS:ESP + 28] = EAX; /* charset */
					EAX = sig0048_textbox->y_size;
					EBP = sig0048_textbox->x_size;
					*sig0048_textbox_ycnt = EAX;
					EDX = sig0048_textbox->x0;
					EAX = sig0048_textbox->y0;
					LEA(EDI, sig0048_textbox->buffer);
					do {
						(int) [SS:ESP + 16] = EAX; /* y0 */
						do {
							// EDX, (EAX)から書き込むルーチン
							LEA(EBX, [SS:ESP + 40]);
							(int) [SS:ESP + 12] = EDX; /* x0 */
							EAX = (int) [DS:EDI    ];
							ECX = (int) [DS:EDI + 4];
							EDI += 8;
							(int) [DS:EBX - 4] = EAX;
							EAX = ECX;
							ECX >>= 16;
							EAX &= 0xffff;
							(int) [SS:ESP + 24] = ECX; /* backcolor */
							(int) [SS:ESP + 20] = EAX; /* color */
							EDX += 8; /* x */
							EBP--; /* xcnt */
							ECX = (int) [DS:EDI - 4];
							if (!= 0) {
								do {
									if (ECX != (int) [DS:EDI + 4])
										break;
									EAX = (int) [DS:EDI];
									EDI += 8;
									(int) [DS:EBX] = EAX;
									EBX += 4;
									EDX += 8; /* x */
									EBP--; /* xcnt */
								} while (!= 0);
							}
							(int) [DS:EBX] = 0x0000; /* end of command */
							EBX -= ESP;
							EBX -= 36;
							EBX /= 4;
							(int) [SS:ESP +  32] = EBX; /* length */
							EBX = ESP;
							DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
						} while (EBP != 0);
						EAX = (int) [SS:ESP + 16] /* y0 */;
						EBP = sig0048_textbox->x_size;
						CL = (char) sig0048_textbox->option;
						EAX += 8;
						TEST(CL, 0x10);
						if (== 0)
							EAX += 8;
						EDX = sig0048_textbox->x0;
						*sig0048_textbox_ycnt--;
					} while (!= 0);
					EDX = *sig0048_textbox_saveEDX;
					EBP = *sig0048_textbox_saveEBP;
					EDI = *sig0048_textbox_saveEDI;
				} else {
					// wintitle
					// バッファを参照して書き込む
					int *sig0048_textbox_saveESI == SS:ESP + 508; // textbox
					*sig0048_textbox_saveESI = ESI;
					(int) [SS:ESP     ] = 0x0404; /* put text */
					(int) [SS:ESP +  4] = 0x0000; /* option */
				//	(int) [SS:ESP +  8] = EDX;
					EAX = sig0048_win->mode0;
					(int) [SS:ESP + 12] = 24; /* x0 */
					asmout("MOV EAX,CS:[EAX*4+#wintitle_colortable]");
					(int) [SS:ESP + 16] =  5; /* y0 */
					ECX = EAX;
					EAX &= 0xff;
					ECX /= 256;
					(int) [SS:ESP + 20] = EAX; /* color */
					(int) [SS:ESP + 24] = ECX; /* backcolor */
					EAX = sig0048_textbox->charset;
					ECX = sig0048_textbox->x_size;
					(int) [SS:ESP + 28] = EAX; /* charset */
					(int) [SS:ESP + 32] = ECX; /* length */
					ESI += 64; // seek buffer head
					LEA(EBX, [SS:ESP + 36]);
					do {
						EAX = (int) [DS:ESI];
						ESI += 8;
						(int) [DS:EBX] = EAX;
						EBX += 4;
						ECX--;
					} while (!= 0);
					(int) [DS:EBX] = /* 0x0000 */ ECX; /* end of command */
					EBX = ESP;
					DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
					ESI = *sig0048_textbox_saveESI;
				}
			} else {
				INT(0x03);
			}
			LEA(EAX, sig0048_win->children_back);
			ESI = (int) [DS:ESI + 12 /* chain_next */];
		} while (EAX != ESI);
	}
	// 描画完了通知シグナル
	PUSH((int) 0);
	PUSH(EDX);
	PUSH((int) 0x0144);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 512 + 12;
	POP(ESI);
//	goto nextsignal;

nextsignal:
		// モードチェンジ、window位置変更、VRAMアクセスの自由化の後には、再描画が来るのをあてにしてよい。
	} while (work->signaldw < 8);

	POP(GS);
	POP(DS);

	work->read_ptr = (offset) signal;

	// スタックを乱してリターンしてはいけない
	EAX = work->signaldw;
	LEA(EBX, work->softint_ret_buf[0]);
	work->softint_ret_buf[ 4] = EAX;
	work->softint_ret_buf[ 8] = 0x0001;
	if (work->nest == 0) {
		if (work->signalbox_read_free != 0) {
			if ((unsigned) (short) [SS:ESP + 40 /* CS */] != 0x00c7) {
				// 新規割り込み
				POP(EAX); // FS
				PUSH(GS);
				PUSH(EAX);
				PUSH(DS);
				PUSH(ES);
				ESP -= 44;
				PUSH(EAX);
				EAX = work->softint_EIP;
				ECX = work->softint_CS;
				EDX = (int) [SS:ESP + 104 /* EFLAGS */];
				(int) [SS:ESP + 16] = 0x02; // リターン時にLlv2へ。
				(int) [SS:ESP + 36 /* EIP */   ] = EAX;
				(int) [SS:ESP + 40 /* CS */    ] = ECX;
				(int) [SS:ESP + 44 /* EFLAGS */] = EDX;
				work->nest--;
			}
		}
	}
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	// エラーがない限り、ここには来ない
	INT(0x03);
	ALIGN(4);
	asmout("#wintitle_colortable DD 0008H, 0708H, 0, 040FH");
}

void near textbox_drawback()
// EDX:win_slot, ESI:textbox
// EAX, ECX, EBXを破壊
{
	PUSH(EBP);
	PUSH(EAX);
	ESP -= 128 + 4;
	EBP = ESP;

	int *cmd == SS:EBP;
	TEXTBOX *textbox == DS:ESI;

	EAX = 0x0400;
	ECX = 0x0020;
	cmd[  0] = EAX /* line command */;
	cmd[  4] = ECX /* option(box-fill) */;
	cmd[  8] = EDX /* window(slot-no) */;
	cmd[ 32] = EAX /* line command */;
	cmd[ 36] = ECX /* option(box-fill) */;
	cmd[ 40] = EDX /* window(slot-no) */;
	cmd[ 64] = EAX /* line command */;
	cmd[ 68] = ECX /* option(box-fill) */;
	cmd[ 72] = EDX /* window(slot-no) */;
	cmd[ 96] = EAX /* line command */;
	cmd[100] = ECX /* option(box-fill) */;
	cmd[104] = EDX /* window(slot-no) */;
	cmd[128] = 0x0000 /* end of command */;
	EAX = textbox->x0;
	ECX = textbox->y0;
	EAX -= 3;
	ECX -= 3;
	cmd[ 12] = EAX /* x0 */;
	cmd[ 16] = ECX /* y0 */;
	cmd[ 24] = ECX /* y1 */;
	cmd[ 44] = EAX /* x0 */;
	cmd[ 48] = ECX /* y0 */;
	cmd[ 52] = EAX /* x1 */;
	cmd[ 76] = EAX /* x0 */;
	cmd[112] = ECX /* y0 */;
	EAX = textbox->x_size;
	ECX = textbox->y_size;
	EAX *= 8;
	ECX *= 8;
	TEST(textbox->option, 0x10);
	if (== 0) {
		ECX *= 2;
	}
	EAX += textbox->x0;
	ECX += textbox->y0;
	EAX += 2;
	ECX += 2;
	EBX = 0;
	cmd[ 20] = EAX /* x1 */;
	cmd[ 56] = ECX /* y1 */;
	cmd[ 80] = ECX /* y0 */;
	cmd[ 84] = EAX /* x1 */;
	cmd[ 88] = ECX /* y1 */;
	cmd[108] = EAX /* x0 */;
	cmd[116] = EAX /* x1 */;
	cmd[120] = ECX /* y1 */;
	LEA(EAX, [EBX + 7]);
	LEA(ECX, [EBX + 15]);
	cmd[ 28] = /*  7 */ EAX /* color */;
	cmd[ 60] = /*  7 */ EAX /* color */;
	cmd[ 92] = /* 15 */ ECX /* color */;
	cmd[124] = /* 15 */ ECX /* color */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EAX = cmd[ 12];
	ECX = cmd[ 16];
	EAX++;
	ECX++;
	cmd[ 12] = EAX /* x0 */;
	cmd[ 16] = ECX /* y0 */;
	cmd[ 24] = ECX /* y1 */;
	cmd[ 44] = EAX /* x0 */;
	cmd[ 48] = ECX /* y0 */;
	cmd[ 52] = EAX /* x1 */;
	cmd[ 76] = EAX /* x0 */;
	cmd[112] = ECX /* y0 */;
	EAX = cmd[116];
	ECX = cmd[120];
	EAX--;
	ECX--;
	EBX = 0;
	cmd[ 20] = EAX /* x1 */;
	cmd[ 56] = ECX /* y1 */;
	cmd[ 80] = ECX /* y0 */;
	cmd[ 84] = EAX /* x1 */;
	cmd[ 88] = ECX /* y1 */;
	cmd[108] = EAX /* x0 */;
	cmd[116] = EAX /* x1 */;
	cmd[120] = ECX /* y1 */;
	LEA(EAX, [EBX + 8]);
	cmd[ 28] = /* 0 */ EBX /* color */;
	cmd[ 60] = /* 0 */ EBX /* color */;
	cmd[ 92] = /* 8 */ EAX /* color */;
	cmd[124] = /* 8 */ EAX /* color */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EBX = [SS:ESP + 128 + 4];
	EAX = cmd[ 12];
	ECX = cmd[ 16];
	cmd[  4] = EBX; // opt
	EAX++;
	ECX++;
	cmd[ 12] = EAX /* x0 */;
	cmd[ 16] = ECX /* y0 */;
	EAX = cmd[116];
	ECX = cmd[120];
	EAX--;
	ECX--;
	cmd[ 20] = EAX /* x1 */;
	cmd[ 24] = ECX /* y1 */;
	EAX = textbox->backcolor;
	cmd[ 28] = EAX /* color */;
	cmd[ 32] = 0x0000 /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 128 + 4;
	POP(EAX);
	POP(EBP);
	return;
}
